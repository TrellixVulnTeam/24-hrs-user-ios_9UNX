{"version":3,"file":"keyboard.js","sources":["keyboard.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;sGAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;2JAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, Injectable, NgZone } from '@angular/core';\nimport { Config } from '../config/config';\nimport { DomController } from './dom-controller';\nimport { isTextInput } from '../util/dom';\nimport { KEY_TAB } from './key';\nimport { Platform } from './platform';\n/**\n * \\@name Keyboard\n * \\@description\n * The `Keyboard` class allows you to work with the keyboard events provided\n * by the Ionic keyboard plugin.\n *\n * \\@usage\n * ```ts\n * export class MyClass {\n *   constructor(public keyboard: Keyboard) {\n *\n *   }\n * }\n * ```\n */\nexport class Keyboard {\n    /**\n     * @param {?} config\n     * @param {?} _plt\n     * @param {?} _zone\n     * @param {?} _dom\n     */\n    constructor(config, _plt, _zone, _dom) {\n        this._plt = _plt;\n        this._zone = _zone;\n        this._dom = _dom;\n        this.willShow = new EventEmitter();\n        this.willHide = new EventEmitter();\n        this.didShow = new EventEmitter();\n        this.didHide = new EventEmitter();\n        this.eventsAvailable = false;\n        this.focusOutline(config.get('focusOutline'));\n        const win = _plt.win();\n        if (config.getBoolean('keyboardResizes', false)) {\n            this.listenV2(win);\n        }\n        else {\n            this.listenV1(win);\n        }\n    }\n    /**\n     * @param {?} win\n     * @return {?}\n     */\n    listenV2(win) {\n        const /** @type {?} */ platform = this._plt;\n        platform.registerListener(win, 'keyboardWillShow', () => {\n            this._zone.run(() => {\n                this.willShow.emit();\n            });\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'keyboardWillHide', () => {\n            this._zone.run(() => {\n                this.willHide.emit();\n            });\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'keyboardDidShow', () => {\n            this._zone.run(() => {\n                this.didShow.emit();\n            });\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'keyboardDidHide', () => {\n            this._zone.run(() => {\n                this.didHide.emit();\n            });\n        }, { zone: false, passive: true });\n        this.eventsAvailable = true;\n    }\n    /**\n     * @param {?} win\n     * @return {?}\n     */\n    listenV1(win) {\n        const /** @type {?} */ platform = this._plt;\n        platform.registerListener(win, 'native.keyboardhide', () => {\n            this.blurActiveInput(true);\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'native.keyboardshow', () => {\n            this.blurActiveInput(false);\n        }, { zone: false, passive: true });\n    }\n    /**\n     * @param {?} shouldBlur\n     * @return {?}\n     */\n    blurActiveInput(shouldBlur) {\n        const /** @type {?} */ platform = this._plt;\n        platform.cancelTimeout(this._tmr);\n        if (shouldBlur) {\n            this._tmr = platform.timeout(() => {\n                // this custom cordova plugin event fires when the keyboard will hide\n                // useful when the virtual keyboard is closed natively\n                // https://github.com/ionic-team/ionic-plugin-keyboard\n                if (this.isOpen()) {\n                    platform.focusOutActiveElement();\n                }\n            }, 80);\n        }\n    }\n    /**\n     * Check to see if the keyboard is open or not.\n     *\n     * ```ts\n     * export class MyClass {\n     *   constructor(public keyboard: Keyboard) {\n     *\n     *   }\n     *\n     *   keyboardCheck() {\n     *     console.log('The keyboard is open:', this.keyboard.isOpen());\n     *   }\n     * }\n     * ```\n     *\n     * @return {?}\n     */\n    isOpen() {\n        return this.hasFocusedTextInput();\n    }\n    /**\n     * When the keyboard is closed, call any methods you want.\n     *\n     * ```ts\n     * export class MyClass {\n     *   constructor(public keyboard: Keyboard) {\n     *     this.keyboard.onClose(this.closeCallback);\n     *   }\n     *   closeCallback() {\n     *     // call what ever functionality you want on keyboard close\n     *     console.log('Closing time');\n     *   }\n     * }\n     * ```\n     *\n     * @param {?} callback\n     * @param {?=} pollingInternval\n     * @param {?=} pollingChecksMax\n     * @return {?}\n     */\n    onClose(callback, pollingInternval = KEYBOARD_CLOSE_POLLING, pollingChecksMax = KEYBOARD_POLLING_CHECKS_MAX) {\n        (void 0) /* console.debug */;\n        const /** @type {?} */ self = this;\n        let /** @type {?} */ checks = 0;\n        let /** @type {?} */ promise = null;\n        if (!callback) {\n            // a callback wasn't provided, so let's return a promise instead\n            promise = new Promise(resolve => { callback = resolve; });\n        }\n        /**\n         * @return {?}\n         */\n        function checkKeyboard() {\n            (void 0) /* console.debug */;\n            if (!self.isOpen() || checks > pollingChecksMax) {\n                self._plt.timeout(function () {\n                    self._zone.run(function () {\n                        (void 0) /* console.debug */;\n                        callback();\n                    });\n                }, 400);\n            }\n            else {\n                self._plt.timeout(checkKeyboard, pollingInternval);\n            }\n            checks++;\n        }\n        self._plt.timeout(checkKeyboard, pollingInternval);\n        return promise;\n    }\n    /**\n     * Programmatically close the keyboard.\n     * @return {?}\n     */\n    close() {\n        this._dom.read(() => {\n            if (this.isOpen()) {\n                // only focus out when a text input has focus\n                (void 0) /* console.debug */;\n                this._dom.write(() => {\n                    this._plt.focusOutActiveElement();\n                });\n            }\n        });\n    }\n    /**\n     * @hidden\n     * @param {?} setting\n     * @return {?}\n     */\n    focusOutline(setting) {\n        /* Focus Outline\n         * --------------------------------------------------\n         * By default, when a keydown event happens from a tab key, then\n         * the 'focus-outline' css class is added to the body element\n         * so focusable elements have an outline. On a mousedown or\n         * touchstart event, then the 'focus-outline' css class is removed.\n         *\n         * Config default overrides:\n         * focusOutline: true     - Always add the focus-outline\n         * focusOutline: false    - Do not add the focus-outline\n         */\n        const /** @type {?} */ self = this;\n        const /** @type {?} */ platform = self._plt;\n        const /** @type {?} */ doc = platform.doc();\n        let /** @type {?} */ isKeyInputEnabled = false;\n        let /** @type {?} */ unRegMouse;\n        let /** @type {?} */ unRegTouch;\n        const /** @type {?} */ evOpts = { passive: true, zone: false };\n        /**\n         * @return {?}\n         */\n        function cssClass() {\n            self._dom.write(() => {\n                ((platform.doc().body.classList))[isKeyInputEnabled ? 'add' : 'remove']('focus-outline');\n            });\n        }\n        if (setting === true) {\n            isKeyInputEnabled = true;\n            return cssClass();\n        }\n        else if (setting === false) {\n            return;\n        }\n        /**\n         * @param {?} ev\n         * @return {?}\n         */\n        function keyDown(ev) {\n            if (!isKeyInputEnabled && ev.keyCode === KEY_TAB) {\n                isKeyInputEnabled = true;\n                enableKeyInput();\n            }\n        }\n        /**\n         * @return {?}\n         */\n        function pointerDown() {\n            isKeyInputEnabled = false;\n            enableKeyInput();\n        }\n        /**\n         * @return {?}\n         */\n        function enableKeyInput() {\n            cssClass();\n            unRegMouse && unRegMouse();\n            unRegTouch && unRegTouch();\n            if (isKeyInputEnabled) {\n                // listen for when a mousedown or touchstart event happens\n                unRegMouse = platform.registerListener(doc, 'mousedown', pointerDown, evOpts);\n                unRegTouch = platform.registerListener(doc, 'touchstart', pointerDown, evOpts);\n            }\n        }\n        // always listen for tab keydown events\n        platform.registerListener(platform.doc(), 'keydown', keyDown, evOpts);\n    }\n    /**\n     * @return {?}\n     */\n    hasFocusedTextInput() {\n        const /** @type {?} */ activeEle = this._plt.getActiveElement();\n        if (isTextInput(activeEle)) {\n            return (activeEle.parentElement.querySelector(':focus') === activeEle);\n        }\n        return false;\n    }\n}\nKeyboard.decorators = [\n    { type: Injectable },\n];\n/**\n * @nocollapse\n */\nKeyboard.ctorParameters = () => [\n    { type: Config, },\n    { type: Platform, },\n    { type: NgZone, },\n    { type: DomController, },\n];\nfunction Keyboard_tsickle_Closure_declarations() {\n    /** @type {?} */\n    Keyboard.decorators;\n    /**\n     * @nocollapse\n     * @type {?}\n     */\n    Keyboard.ctorParameters;\n    /** @type {?} */\n    Keyboard.prototype._tmr;\n    /** @type {?} */\n    Keyboard.prototype.willShow;\n    /** @type {?} */\n    Keyboard.prototype.willHide;\n    /** @type {?} */\n    Keyboard.prototype.didShow;\n    /** @type {?} */\n    Keyboard.prototype.didHide;\n    /** @type {?} */\n    Keyboard.prototype.eventsAvailable;\n    /** @type {?} */\n    Keyboard.prototype._plt;\n    /** @type {?} */\n    Keyboard.prototype._zone;\n    /** @type {?} */\n    Keyboard.prototype._dom;\n}\nconst /** @type {?} */ KEYBOARD_CLOSE_POLLING = 150;\nconst /** @type {?} */ KEYBOARD_POLLING_CHECKS_MAX = 100;\n"]}