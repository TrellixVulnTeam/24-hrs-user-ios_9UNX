{"version":3,"file":"picker-column.js","sources":["picker-column.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;wEAmBE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Component, ElementRef, EventEmitter, Input, NgZone, Output, ViewChild } from '@angular/core';\nimport { clamp } from '../../util/util';\nimport { Config } from '../../config/config';\nimport { DomController } from '../../platform/dom-controller';\nimport { Haptic } from '../../tap-click/haptic';\nimport { DECELERATION_FRICTION, FRAME_MS, MAX_PICKER_SPEED, PICKER_OPT_SELECTED } from './picker-options';\nimport { Platform } from '../../platform/platform';\nimport { pointerCoord } from '../../util/dom';\nimport { UIEventManager } from '../../gestures/ui-event-manager';\n/**\n * @hidden\n */\nexport class PickerColumnCmp {\n    /**\n     * @param {?} config\n     * @param {?} _plt\n     * @param {?} elementRef\n     * @param {?} _zone\n     * @param {?} _haptic\n     * @param {?} plt\n     * @param {?} domCtrl\n     */\n    constructor(config, _plt, elementRef, _zone, _haptic, plt, domCtrl) {\n        this._plt = _plt;\n        this.elementRef = elementRef;\n        this._zone = _zone;\n        this._haptic = _haptic;\n        this.y = 0;\n        this.pos = [];\n        this.startY = null;\n        this.ionChange = new EventEmitter();\n        this.events = new UIEventManager(plt);\n        this.rotateFactor = config.getNumber('pickerRotateFactor', 0);\n        this.scaleFactor = config.getNumber('pickerScaleFactor', 1);\n        this.decelerateFunc = this.decelerate.bind(this);\n        this.debouncer = domCtrl.debouncer();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        // get the scrollable element within the column\n        let /** @type {?} */ colEle = this.colEle.nativeElement;\n        this.colHeight = colEle.clientHeight;\n        // get the height of one option\n        this.optHeight = (colEle.firstElementChild ? colEle.firstElementChild.clientHeight : 0);\n        // Listening for pointer events\n        this.events.pointerEvents({\n            element: this.elementRef.nativeElement,\n            pointerDown: this.pointerStart.bind(this),\n            pointerMove: this.pointerMove.bind(this),\n            pointerUp: this.pointerEnd.bind(this),\n            capture: true,\n            zone: false\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._plt.cancelRaf(this.rafId);\n        this.events.destroy();\n    }\n    /**\n     * @param {?} ev\n     * @return {?}\n     */\n    pointerStart(ev) {\n        (void 0) /* console.debug */;\n        this._haptic.gestureSelectionStart();\n        // We have to prevent default in order to block scrolling under the picker\n        // but we DO NOT have to stop propagation, since we still want\n        // some \"click\" events to capture\n        ev.preventDefault();\n        // cancel any previous raf's that haven't fired yet\n        this._plt.cancelRaf(this.rafId);\n        // remember where the pointer started from`\n        this.startY = pointerCoord(ev).y;\n        // reset everything\n        this.velocity = 0;\n        this.pos.length = 0;\n        this.pos.push(this.startY, Date.now());\n        let /** @type {?} */ options = this.col.options;\n        let /** @type {?} */ minY = (options.length - 1);\n        let /** @type {?} */ maxY = 0;\n        for (var /** @type {?} */ i = 0; i < options.length; i++) {\n            if (!options[i].disabled) {\n                minY = Math.min(minY, i);\n                maxY = Math.max(maxY, i);\n            }\n        }\n        this.minY = (minY * this.optHeight * -1);\n        this.maxY = (maxY * this.optHeight * -1);\n        return true;\n    }\n    /**\n     * @param {?} ev\n     * @return {?}\n     */\n    pointerMove(ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n        let /** @type {?} */ currentY = pointerCoord(ev).y;\n        this.pos.push(currentY, Date.now());\n        this.debouncer.write(() => {\n            if (this.startY === null) {\n                return;\n            }\n            // update the scroll position relative to pointer start position\n            let /** @type {?} */ y = this.y + (currentY - this.startY);\n            if (y > this.minY) {\n                // scrolling up higher than scroll area\n                y = Math.pow(y, 0.8);\n                this.bounceFrom = y;\n            }\n            else if (y < this.maxY) {\n                // scrolling down below scroll area\n                y += Math.pow(this.maxY - y, 0.9);\n                this.bounceFrom = y;\n            }\n            else {\n                this.bounceFrom = 0;\n            }\n            this.update(y, 0, false, false);\n            let /** @type {?} */ currentIndex = Math.max(Math.abs(Math.round(y / this.optHeight)), 0);\n            if (currentIndex !== this.lastTempIndex) {\n                // Trigger a haptic event for physical feedback that the index has changed\n                this._haptic.gestureSelectionChanged();\n                this.lastTempIndex = currentIndex;\n            }\n        });\n    }\n    /**\n     * @param {?} ev\n     * @return {?}\n     */\n    pointerEnd(ev) {\n        ev.preventDefault();\n        this.debouncer.cancel();\n        if (this.startY === null) {\n            return;\n        }\n        (void 0) /* console.debug */;\n        this.velocity = 0;\n        if (this.bounceFrom > 0) {\n            // bounce back up\n            this.update(this.minY, 100, true, true);\n            return;\n        }\n        else if (this.bounceFrom < 0) {\n            // bounce back down\n            this.update(this.maxY, 100, true, true);\n            return;\n        }\n        let /** @type {?} */ endY = pointerCoord(ev).y;\n        this.pos.push(endY, Date.now());\n        let /** @type {?} */ endPos = (this.pos.length - 1);\n        let /** @type {?} */ startPos = endPos;\n        let /** @type {?} */ timeRange = (Date.now() - 100);\n        // move pointer to position measured 100ms ago\n        for (var /** @type {?} */ i = endPos; i > 0 && this.pos[i] > timeRange; i -= 2) {\n            startPos = i;\n        }\n        if (startPos !== endPos) {\n            // compute relative movement between these two points\n            var /** @type {?} */ timeOffset = (this.pos[endPos] - this.pos[startPos]);\n            var /** @type {?} */ movedTop = (this.pos[startPos - 1] - this.pos[endPos - 1]);\n            // based on XXms compute the movement to apply for each render step\n            var /** @type {?} */ velocity = ((movedTop / timeOffset) * FRAME_MS);\n            this.velocity = clamp(-MAX_PICKER_SPEED, velocity, MAX_PICKER_SPEED);\n        }\n        if (Math.abs(endY - this.startY) > 3) {\n            var /** @type {?} */ y = this.y + (endY - this.startY);\n            this.update(y, 0, true, true);\n        }\n        this.startY = null;\n        this.decelerate();\n    }\n    /**\n     * @return {?}\n     */\n    decelerate() {\n        let /** @type {?} */ y = 0;\n        if (isNaN(this.y) || !this.optHeight) {\n            // fallback in case numbers get outta wack\n            this.update(y, 0, true, true);\n            this._haptic.gestureSelectionEnd();\n        }\n        else if (Math.abs(this.velocity) > 0) {\n            // still decelerating\n            this.velocity *= DECELERATION_FRICTION;\n            // do not let it go slower than a velocity of 1\n            this.velocity = (this.velocity > 0)\n                ? Math.max(this.velocity, 1)\n                : Math.min(this.velocity, -1);\n            y = Math.round(this.y - this.velocity);\n            if (y > this.minY) {\n                // whoops, it's trying to scroll up farther than the options we have!\n                y = this.minY;\n                this.velocity = 0;\n            }\n            else if (y < this.maxY) {\n                // gahh, it's trying to scroll down farther than we can!\n                y = this.maxY;\n                this.velocity = 0;\n            }\n            var /** @type {?} */ notLockedIn = (y % this.optHeight !== 0 || Math.abs(this.velocity) > 1);\n            this.update(y, 0, true, !notLockedIn);\n            if (notLockedIn) {\n                // isn't locked in yet, keep decelerating until it is\n                this.rafId = this._plt.raf(this.decelerateFunc);\n            }\n        }\n        else if (this.y % this.optHeight !== 0) {\n            // needs to still get locked into a position so options line up\n            var /** @type {?} */ currentPos = Math.abs(this.y % this.optHeight);\n            // create a velocity in the direction it needs to scroll\n            this.velocity = (currentPos > (this.optHeight / 2) ? 1 : -1);\n            this._haptic.gestureSelectionEnd();\n            this.decelerate();\n        }\n        let /** @type {?} */ currentIndex = Math.max(Math.abs(Math.round(y / this.optHeight)), 0);\n        if (currentIndex !== this.lastTempIndex) {\n            // Trigger a haptic event for physical feedback that the index has changed\n            this._haptic.gestureSelectionChanged();\n        }\n        this.lastTempIndex = currentIndex;\n    }\n    /**\n     * @param {?} ev\n     * @param {?} index\n     * @return {?}\n     */\n    optClick(ev, index) {\n        if (!this.velocity) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this.setSelected(index, 150);\n        }\n    }\n    /**\n     * @param {?} selectedIndex\n     * @param {?} duration\n     * @return {?}\n     */\n    setSelected(selectedIndex, duration) {\n        // if there is a selected index, then figure out it's y position\n        // if there isn't a selected index, then just use the top y position\n        let /** @type {?} */ y = (selectedIndex > -1) ? ((selectedIndex * this.optHeight) * -1) : 0;\n        this._plt.cancelRaf(this.rafId);\n        this.velocity = 0;\n        // so what y position we're at\n        this.update(y, duration, true, true);\n    }\n    /**\n     * @param {?} y\n     * @param {?} duration\n     * @param {?} saveY\n     * @param {?} emitChange\n     * @return {?}\n     */\n    update(y, duration, saveY, emitChange) {\n        // ensure we've got a good round number :)\n        y = Math.round(y);\n        let /** @type {?} */ i;\n        let /** @type {?} */ button;\n        let /** @type {?} */ opt;\n        let /** @type {?} */ optOffset;\n        let /** @type {?} */ visible;\n        let /** @type {?} */ translateX;\n        let /** @type {?} */ translateY;\n        let /** @type {?} */ translateZ;\n        let /** @type {?} */ rotateX;\n        let /** @type {?} */ transform;\n        let /** @type {?} */ selected;\n        const /** @type {?} */ parent = this.colEle.nativeElement;\n        const /** @type {?} */ children = parent.children;\n        const /** @type {?} */ length = children.length;\n        const /** @type {?} */ selectedIndex = this.col.selectedIndex = Math.min(Math.max(Math.round(-y / this.optHeight), 0), length - 1);\n        const /** @type {?} */ durationStr = (duration === 0) ? null : duration + 'ms';\n        const /** @type {?} */ scaleStr = `scale(${this.scaleFactor})`;\n        for (i = 0; i < length; i++) {\n            button = children[i];\n            opt = (this.col.options[i]);\n            optOffset = (i * this.optHeight) + y;\n            visible = true;\n            transform = '';\n            if (this.rotateFactor !== 0) {\n                rotateX = optOffset * this.rotateFactor;\n                if (Math.abs(rotateX) > 90) {\n                    visible = false;\n                }\n                else {\n                    translateX = 0;\n                    translateY = 0;\n                    translateZ = 90;\n                    transform = `rotateX(${rotateX}deg) `;\n                }\n            }\n            else {\n                translateX = 0;\n                translateZ = 0;\n                translateY = optOffset;\n                if (Math.abs(translateY) > 170) {\n                    visible = false;\n                }\n            }\n            selected = selectedIndex === i;\n            if (visible) {\n                transform += `translate3d(0px,${translateY}px,${translateZ}px) `;\n                if (this.scaleFactor !== 1 && !selected) {\n                    transform += scaleStr;\n                }\n            }\n            else {\n                transform = 'translate3d(-9999px,0px,0px)';\n            }\n            // Update transition duration\n            if (duration !== opt._dur) {\n                opt._dur = duration;\n                button.style[this._plt.Css.transitionDuration] = durationStr;\n            }\n            // Update transform\n            if (transform !== opt._trans) {\n                opt._trans = transform;\n                button.style[this._plt.Css.transform] = transform;\n            }\n            // Update selected item\n            if (selected !== opt._selected) {\n                opt._selected = selected;\n                if (selected) {\n                    button.classList.add(PICKER_OPT_SELECTED);\n                }\n                else {\n                    button.classList.remove(PICKER_OPT_SELECTED);\n                }\n            }\n        }\n        this.col.prevSelected = selectedIndex;\n        if (saveY) {\n            this.y = y;\n        }\n        if (emitChange) {\n            if (this.lastIndex === undefined) {\n                // have not set a last index yet\n                this.lastIndex = this.col.selectedIndex;\n            }\n            else if (this.lastIndex !== this.col.selectedIndex) {\n                // new selected index has changed from the last index\n                // update the lastIndex and emit that it has changed\n                this.lastIndex = this.col.selectedIndex;\n                var /** @type {?} */ ionChange = this.ionChange;\n                if (ionChange.observers.length > 0) {\n                    this._zone.run(ionChange.emit.bind(ionChange, this.col.options[this.col.selectedIndex]));\n                }\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    refresh() {\n        let /** @type {?} */ min = this.col.options.length - 1;\n        let /** @type {?} */ max = 0;\n        const /** @type {?} */ options = this.col.options;\n        for (var /** @type {?} */ i = 0; i < options.length; i++) {\n            if (!options[i].disabled) {\n                min = Math.min(min, i);\n                max = Math.max(max, i);\n            }\n        }\n        const /** @type {?} */ selectedIndex = clamp(min, this.col.selectedIndex, max);\n        if (this.col.prevSelected !== selectedIndex) {\n            var /** @type {?} */ y = (selectedIndex * this.optHeight) * -1;\n            this._plt.cancelRaf(this.rafId);\n            this.velocity = 0;\n            this.update(y, 150, true, false);\n        }\n    }\n}\nPickerColumnCmp.decorators = [\n    { type: Component, args: [{\n                selector: '.picker-col',\n                template: '<div *ngIf=\"col.prefix\" class=\"picker-prefix\" [style.width]=\"col.prefixWidth\">{{col.prefix}}</div>' +\n                    '<div class=\"picker-opts\" #colEle [style.max-width]=\"col.optionsWidth\">' +\n                    '<button *ngFor=\"let o of col.options; let i=index\"' +\n                    '[class.picker-opt-disabled]=\"o.disabled\" ' +\n                    'class=\"picker-opt\" disable-activated (click)=\"optClick($event, i)\">' +\n                    '{{o.text}}' +\n                    '</button>' +\n                    '</div>' +\n                    '<div *ngIf=\"col.suffix\" class=\"picker-suffix\" [style.width]=\"col.suffixWidth\">{{col.suffix}}</div>',\n                host: {\n                    '[style.max-width]': 'col.columnWidth',\n                    '[class.picker-opts-left]': 'col.align==\"left\"',\n                    '[class.picker-opts-right]': 'col.align==\"right\"',\n                }\n            },] },\n];\n/**\n * @nocollapse\n */\nPickerColumnCmp.ctorParameters = () => [\n    { type: Config, },\n    { type: Platform, },\n    { type: ElementRef, },\n    { type: NgZone, },\n    { type: Haptic, },\n    { type: Platform, },\n    { type: DomController, },\n];\nPickerColumnCmp.propDecorators = {\n    'colEle': [{ type: ViewChild, args: ['colEle',] },],\n    'col': [{ type: Input },],\n    'ionChange': [{ type: Output },],\n};\nfunction PickerColumnCmp_tsickle_Closure_declarations() {\n    /** @type {?} */\n    PickerColumnCmp.decorators;\n    /**\n     * @nocollapse\n     * @type {?}\n     */\n    PickerColumnCmp.ctorParameters;\n    /** @type {?} */\n    PickerColumnCmp.propDecorators;\n    /** @type {?} */\n    PickerColumnCmp.prototype.colEle;\n    /** @type {?} */\n    PickerColumnCmp.prototype.col;\n    /** @type {?} */\n    PickerColumnCmp.prototype.y;\n    /** @type {?} */\n    PickerColumnCmp.prototype.colHeight;\n    /** @type {?} */\n    PickerColumnCmp.prototype.optHeight;\n    /** @type {?} */\n    PickerColumnCmp.prototype.velocity;\n    /** @type {?} */\n    PickerColumnCmp.prototype.pos;\n    /** @type {?} */\n    PickerColumnCmp.prototype.startY;\n    /** @type {?} */\n    PickerColumnCmp.prototype.rafId;\n    /** @type {?} */\n    PickerColumnCmp.prototype.bounceFrom;\n    /** @type {?} */\n    PickerColumnCmp.prototype.minY;\n    /** @type {?} */\n    PickerColumnCmp.prototype.maxY;\n    /** @type {?} */\n    PickerColumnCmp.prototype.rotateFactor;\n    /** @type {?} */\n    PickerColumnCmp.prototype.scaleFactor;\n    /** @type {?} */\n    PickerColumnCmp.prototype.lastIndex;\n    /** @type {?} */\n    PickerColumnCmp.prototype.lastTempIndex;\n    /** @type {?} */\n    PickerColumnCmp.prototype.decelerateFunc;\n    /** @type {?} */\n    PickerColumnCmp.prototype.debouncer;\n    /** @type {?} */\n    PickerColumnCmp.prototype.events;\n    /** @type {?} */\n    PickerColumnCmp.prototype.ionChange;\n    /** @type {?} */\n    PickerColumnCmp.prototype._plt;\n    /** @type {?} */\n    PickerColumnCmp.prototype.elementRef;\n    /** @type {?} */\n    PickerColumnCmp.prototype._zone;\n    /** @type {?} */\n    PickerColumnCmp.prototype._haptic;\n}\n"]}