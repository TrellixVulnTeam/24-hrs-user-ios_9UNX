{"version":3,"file":"item-sliding.js","sources":["item-sliding.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;iDAWE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, NgZone, Optional, Output, Renderer, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { swipeShouldReset } from '../../util/util';\nimport { Item } from './item';\nimport { List } from '../list/list';\nimport { Platform } from '../../platform/platform';\nimport { ItemOptions } from './item-options';\nconst /** @type {?} */ SWIPE_MARGIN = 30;\nconst /** @type {?} */ ELASTIC_FACTOR = 0.55;\nconst /** @type {?} */ ITEM_SIDE_FLAG_NONE = 0;\nconst /** @type {?} */ ITEM_SIDE_FLAG_LEFT = 1 << 0;\nconst /** @type {?} */ ITEM_SIDE_FLAG_RIGHT = 1 << 1;\nconst /** @type {?} */ ITEM_SIDE_FLAG_BOTH = ITEM_SIDE_FLAG_LEFT | ITEM_SIDE_FLAG_RIGHT;\n/**\n * \\@name ItemSliding\n * \\@description\n * A sliding item is a list item that can be swiped to reveal buttons. It requires\n * an [Item](../Item) component as a child and a [List](../../list/List) component as\n * a parent. All buttons to reveal can be placed in the `<ion-item-options>` element.\n *\n * \\@usage\n * ```html\n * <ion-list>\n *   <ion-item-sliding #item>\n *     <ion-item>\n *       Item\n *     </ion-item>\n *     <ion-item-options side=\"left\">\n *       <button ion-button (click)=\"favorite(item)\">Favorite</button>\n *       <button ion-button color=\"danger\" (click)=\"share(item)\">Share</button>\n *     </ion-item-options>\n *\n *     <ion-item-options side=\"right\">\n *       <button ion-button (click)=\"unread(item)\">Unread</button>\n *     </ion-item-options>\n *   </ion-item-sliding>\n * </ion-list>\n * ```\n *\n * ### Swipe Direction\n * By default, the buttons are revealed when the sliding item is swiped from right to left,\n * so the buttons are placed in the right side. But it's also possible to reveal them\n * in the right side (sliding from left to right) by setting the `side` attribute\n * on the `ion-item-options` element. Up to 2 `ion-item-options` can used at the same time\n * in order to reveal two different sets of buttons depending the swipping direction.\n *\n * ```html\n * <ion-item-options side=\"right\">\n *   <button ion-button (click)=\"archive(item)\">\n *     <ion-icon name=\"archive\"></ion-icon>\n *     Archive\n *   </button>\n * </ion-item-options>\n *\n * <ion-item-options side=\"left\">\n *   <button ion-button (click)=\"archive(item)\">\n *     <ion-icon name=\"archive\"></ion-icon>\n *     Archive\n *   </button>\n * </ion-item-options>\n * ```\n *\n * ### Listening for events (ionDrag) and (ionSwipe)\n * It's possible to know the current relative position of the sliding item by subscribing\n * to the (ionDrag)` event.\n *\n * ```html\n * <ion-item-sliding (ionDrag)=\"logDrag($event)\">\n *   <ion-item>Item</ion-item>\n *   <ion-item-options>\n *     <button ion-button>Favorite</button>\n *   </ion-item-options>\n * </ion-item-sliding>\n * ```\n *\n * ### Button Layout\n * If an icon is placed with text in the option button, by default it will\n * display the icon on top of the text. This can be changed to display the icon\n * to the left of the text by setting `icon-start` as an attribute on the\n * `<ion-item-options>` element.\n *\n * ```html\n * <ion-item-options icon-start>\n *    <button ion-button (click)=\"archive(item)\">\n *      <ion-icon name=\"archive\"></ion-icon>\n *      Archive\n *    </button>\n *  </ion-item-options>\n *\n * ```\n *\n * ### Expandable Options\n *\n * Options can be expanded to take up the full width of the item if you swipe past\n * a certain point. This can be combined with the `ionSwipe` event to call methods\n * on the class.\n *\n * ```html\n *\n * <ion-item-sliding (ionSwipe)=\"delete(item)\">\n *   <ion-item>Item</ion-item>\n *   <ion-item-options>\n *     <button ion-button expandable (click)=\"delete(item)\">Delete</button>\n *   </ion-item-options>\n * </ion-item-sliding>\n * ```\n *\n * We can call `delete` by either clicking the button, or by doing a full swipe on the item.\n *\n * \\@demo /docs/demos/src/item-sliding/\n * @see {\\@link /docs/components#lists List Component Docs}\n * @see {\\@link ../Item Item API Docs}\n * @see {\\@link ../../list/List List API Docs}\n */\nexport class ItemSliding {\n    /**\n     * @param {?} list\n     * @param {?} _plt\n     * @param {?} _renderer\n     * @param {?} _elementRef\n     * @param {?} _zone\n     */\n    constructor(list, _plt, _renderer, _elementRef, _zone) {\n        this._plt = _plt;\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n        this._zone = _zone;\n        this._openAmount = 0;\n        this._startX = 0;\n        this._optsWidthRightSide = 0;\n        this._optsWidthLeftSide = 0;\n        this._tmr = null;\n        this._optsDirty = true;\n        this._state = 2 /* Disabled */;\n        /**\n         * \\@output {event} Emitted when the sliding position changes.\n         * It reports the relative position.\n         *\n         * ```ts\n         * ondrag(item) {\n         *   let percent = item.getSlidingPercent();\n         *   if (percent > 0) {\n         *     // positive\n         *     console.log('right side');\n         *   } else {\n         *     // negative\n         *     console.log('left side');\n         *   }\n         *   if (Math.abs(percent) > 1) {\n         *     console.log('overscroll');\n         *   }\n         * }\n         * ```\n         *\n         */\n        this.ionDrag = new EventEmitter();\n        list && list.containsSlidingItem(true);\n        _elementRef.nativeElement.$ionComponent = this;\n        this.setElementClass('item-wrapper', true);\n    }\n    /**\n     * @param {?} itemOptions\n     * @return {?}\n     */\n    set _itemOptions(itemOptions) {\n        let /** @type {?} */ sides = 0;\n        // Reset left and right options in case they were removed\n        this._leftOptions = this._rightOptions = null;\n        for (var /** @type {?} */ item of itemOptions.toArray()) {\n            if (item.isRightSide()) {\n                this._rightOptions = item;\n                sides |= ITEM_SIDE_FLAG_RIGHT;\n            }\n            else {\n                this._leftOptions = item;\n                sides |= ITEM_SIDE_FLAG_LEFT;\n            }\n        }\n        this._optsDirty = true;\n        this._sides = sides;\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n    getOpenAmount() {\n        return this._openAmount;\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n    getSlidingPercent() {\n        const /** @type {?} */ openAmount = this._openAmount;\n        if (openAmount > 0) {\n            return openAmount / this._optsWidthRightSide;\n        }\n        else if (openAmount < 0) {\n            return openAmount / this._optsWidthLeftSide;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * @hidden\n     * @param {?} startX\n     * @return {?}\n     */\n    startSliding(startX) {\n        if (this._tmr) {\n            this._plt.cancelTimeout(this._tmr);\n            this._tmr = null;\n        }\n        if (this._openAmount === 0) {\n            this._optsDirty = true;\n            this._setState(4 /* Enabled */);\n        }\n        this._startX = startX + this._openAmount;\n        this.item.setElementStyle(this._plt.Css.transition, 'none');\n    }\n    /**\n     * @hidden\n     * @param {?} x\n     * @return {?}\n     */\n    moveSliding(x) {\n        if (this._optsDirty) {\n            this.calculateOptsWidth();\n            return;\n        }\n        let /** @type {?} */ openAmount = (this._startX - x);\n        switch (this._sides) {\n            case ITEM_SIDE_FLAG_RIGHT:\n                openAmount = Math.max(0, openAmount);\n                break;\n            case ITEM_SIDE_FLAG_LEFT:\n                openAmount = Math.min(0, openAmount);\n                break;\n            case ITEM_SIDE_FLAG_BOTH: break;\n            case ITEM_SIDE_FLAG_NONE: return;\n            default:\n                (void 0) /* assert */;\n                break;\n        }\n        if (openAmount > this._optsWidthRightSide) {\n            const /** @type {?} */ optsWidth = this._optsWidthRightSide;\n            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n        }\n        else if (openAmount < -this._optsWidthLeftSide) {\n            const /** @type {?} */ optsWidth = -this._optsWidthLeftSide;\n            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;\n        }\n        this._setOpenAmount(openAmount, false);\n        return openAmount;\n    }\n    /**\n     * @hidden\n     * @param {?} velocity\n     * @return {?}\n     */\n    endSliding(velocity) {\n        let /** @type {?} */ restingPoint = (this._openAmount > 0)\n            ? this._optsWidthRightSide\n            : -this._optsWidthLeftSide;\n        // Check if the drag didn't clear the buttons mid-point\n        // and we aren't moving fast enough to swipe open\n        const /** @type {?} */ isResetDirection = (this._openAmount > 0) === !(velocity < 0);\n        const /** @type {?} */ isMovingFast = Math.abs(velocity) > 0.3;\n        const /** @type {?} */ isOnCloseZone = Math.abs(this._openAmount) < Math.abs(restingPoint / 2);\n        if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {\n            restingPoint = 0;\n        }\n        this.fireSwipeEvent();\n        this._setOpenAmount(restingPoint, true);\n        return restingPoint;\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n    fireSwipeEvent() {\n        if (this._state & 32 /* SwipeRight */) {\n            this._zone.run(() => this._rightOptions.ionSwipe.emit(this));\n        }\n        else if (this._state & 64 /* SwipeLeft */) {\n            this._zone.run(() => this._leftOptions.ionSwipe.emit(this));\n        }\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n    calculateOptsWidth() {\n        if (!this._optsDirty) {\n            return;\n        }\n        this._optsWidthRightSide = 0;\n        if (this._rightOptions) {\n            this._optsWidthRightSide = this._rightOptions.width();\n            (void 0) /* assert */;\n        }\n        this._optsWidthLeftSide = 0;\n        if (this._leftOptions) {\n            this._optsWidthLeftSide = this._leftOptions.width();\n            (void 0) /* assert */;\n        }\n        this._optsDirty = false;\n    }\n    /**\n     * @param {?} openAmount\n     * @param {?} isFinal\n     * @return {?}\n     */\n    _setOpenAmount(openAmount, isFinal) {\n        const /** @type {?} */ platform = this._plt;\n        if (this._tmr) {\n            platform.cancelTimeout(this._tmr);\n            this._tmr = null;\n        }\n        this._openAmount = openAmount;\n        if (isFinal) {\n            this.item.setElementStyle(platform.Css.transition, '');\n        }\n        if (openAmount > 0) {\n            var /** @type {?} */ state = (openAmount >= (this._optsWidthRightSide + SWIPE_MARGIN))\n                ? 8 /* Right */ | 32 /* SwipeRight */\n                : 8 /* Right */;\n            this._setState(state);\n        }\n        else if (openAmount < 0) {\n            const /** @type {?} */ state = (openAmount <= (-this._optsWidthLeftSide - SWIPE_MARGIN))\n                ? 16 /* Left */ | 64 /* SwipeLeft */\n                : 16 /* Left */;\n            this._setState(state);\n        }\n        else {\n            (void 0) /* assert */;\n            this._tmr = platform.timeout(() => {\n                this._setState(2 /* Disabled */);\n                this._tmr = null;\n            }, 600);\n            this.item.setElementStyle(platform.Css.transform, '');\n            return;\n        }\n        this.item.setElementStyle(platform.Css.transform, `translate3d(${-openAmount}px,0,0)`);\n        const /** @type {?} */ ionDrag = this.ionDrag;\n        if (ionDrag.observers.length > 0) {\n            ionDrag.emit(this);\n        }\n    }\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n    _setState(state) {\n        if (state === this._state) {\n            return;\n        }\n        this.setElementClass('active-slide', (state !== 2 /* Disabled */));\n        this.setElementClass('active-options-right', !!(state & 8 /* Right */));\n        this.setElementClass('active-options-left', !!(state & 16 /* Left */));\n        this.setElementClass('active-swipe-right', !!(state & 32 /* SwipeRight */));\n        this.setElementClass('active-swipe-left', !!(state & 64 /* SwipeLeft */));\n        this._state = state;\n    }\n    /**\n     * Close the sliding item. Items can also be closed from the [List](../../list/List).\n     *\n     * The sliding item can be closed by grabbing a reference to `ItemSliding`. In the\n     * below example, the template reference variable `slidingItem` is placed on the element\n     * and passed to the `share` method.\n     *\n     * ```html\n     * <ion-list>\n     *   <ion-item-sliding #slidingItem>\n     *     <ion-item>\n     *       Item\n     *     </ion-item>\n     *     <ion-item-options>\n     *       <button ion-button (click)=\"share(slidingItem)\">Share</button>\n     *     </ion-item-options>\n     *   </ion-item-sliding>\n     * </ion-list>\n     * ```\n     *\n     * ```ts\n     * import { Component } from '\\@angular/core';\n     * import { ItemSliding } from 'ionic-angular';\n     *\n     * \\@Component({...})\n     * export class MyClass {\n     *   constructor() { }\n     *\n     *   share(slidingItem: ItemSliding) {\n     *     slidingItem.close();\n     *   }\n     * }\n     * ```\n     * @return {?}\n     */\n    close() {\n        this._setOpenAmount(0, true);\n    }\n    /**\n     * @hidden\n     * @param {?} cssClass\n     * @param {?} shouldAdd\n     * @return {?}\n     */\n    setElementClass(cssClass, shouldAdd) {\n        this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, shouldAdd);\n    }\n}\nItemSliding.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-item-sliding',\n                template: `\n    <ng-content select=\"ion-item,[ion-item]\"></ng-content>\n    <ng-content select=\"ion-item-options\"></ng-content>\n  `,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None\n            },] },\n];\n/**\n * @nocollapse\n */\nItemSliding.ctorParameters = () => [\n    { type: List, decorators: [{ type: Optional },] },\n    { type: Platform, },\n    { type: Renderer, },\n    { type: ElementRef, },\n    { type: NgZone, },\n];\nItemSliding.propDecorators = {\n    'item': [{ type: ContentChild, args: [Item,] },],\n    'ionDrag': [{ type: Output },],\n    '_itemOptions': [{ type: ContentChildren, args: [forwardRef(() => ItemOptions),] },],\n};\nfunction ItemSliding_tsickle_Closure_declarations() {\n    /** @type {?} */\n    ItemSliding.decorators;\n    /**\n     * @nocollapse\n     * @type {?}\n     */\n    ItemSliding.ctorParameters;\n    /** @type {?} */\n    ItemSliding.propDecorators;\n    /** @type {?} */\n    ItemSliding.prototype._openAmount;\n    /** @type {?} */\n    ItemSliding.prototype._startX;\n    /** @type {?} */\n    ItemSliding.prototype._optsWidthRightSide;\n    /** @type {?} */\n    ItemSliding.prototype._optsWidthLeftSide;\n    /** @type {?} */\n    ItemSliding.prototype._sides;\n    /** @type {?} */\n    ItemSliding.prototype._tmr;\n    /** @type {?} */\n    ItemSliding.prototype._leftOptions;\n    /** @type {?} */\n    ItemSliding.prototype._rightOptions;\n    /** @type {?} */\n    ItemSliding.prototype._optsDirty;\n    /** @type {?} */\n    ItemSliding.prototype._state;\n    /**\n     * @hidden\n     * @type {?}\n     */\n    ItemSliding.prototype.item;\n    /**\n     * \\@output {event} Emitted when the sliding position changes.\n     * It reports the relative position.\n     *\n     * ```ts\n     * ondrag(item) {\n     *   let percent = item.getSlidingPercent();\n     *   if (percent > 0) {\n     *     // positive\n     *     console.log('right side');\n     *   } else {\n     *     // negative\n     *     console.log('left side');\n     *   }\n     *   if (Math.abs(percent) > 1) {\n     *     console.log('overscroll');\n     *   }\n     * }\n     * ```\n     *\n     * @type {?}\n     */\n    ItemSliding.prototype.ionDrag;\n    /** @type {?} */\n    ItemSliding.prototype._plt;\n    /** @type {?} */\n    ItemSliding.prototype._renderer;\n    /** @type {?} */\n    ItemSliding.prototype._elementRef;\n    /** @type {?} */\n    ItemSliding.prototype._zone;\n}\n"]}